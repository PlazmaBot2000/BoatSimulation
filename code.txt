#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_ttf.h>
#include <SDL_FontCache.h>
#include "Boat.h"
#include "Engine/Engine_Modules.h"
#include <toml++/toml.hpp>
#include <ctime>
#include <cmath>
#include <format>



FC_Font* DepartureMonoNerdFont = FC_CreateFont(); 
FC_Font* DepartureMonoNerdFontTitle = FC_CreateFont(); 



struct IslandData {
    float drawX, drawY;
    float drawWidth, drawHeight;
    std::vector<Collider> colliders;
};

const double RAD_TO_DEG = 180.0 / 3.141592653589793;
const double DEG_TO_RAD = 3.141592653589793 / 180.0;

const int ISLAND_WIDTH = 62;
const int ISLAND_HEIGHT = 34;
const int ISLAND_MULT = 3;

const int MARGIN = 15;
const int MAX_ATTEMPTS = 500;
int WindowWidth, WindowHeight;

SDL_Texture* ship;
SDL_Texture* light;
SDL_Texture* island;
SDL_Rect rect;
SDL_Point center = {180 / 2, 99 / 2};

SDL_Texture* flagTextures[8]; 
SDL_Rect flagRect;

SDL_Texture* flowArrowTexture;
SDL_Rect flowRect;
SDL_Point flowCenter = { 32, 32 };

auto config = toml::parse_file("Assets/Config/config.toml");

bool game_is_running = true;
bool pause, f = false;
int Prev_Tick = 0;
GameObject Light1, Light2;
Collider finish;

BoatSimulator boat(
    config["ship"]["mass"].value_or(50000),
    config["ship"]["length"].value_or(10),
    config["ship"]["beam"].value_or(3),
    config["ship"]["draft"].value_or(1),
    config["ship"]["height"].value_or(3),
    {50.0, 50.0},
    0.0,
    config["ship"]["startSpeed"].value_or(0.0)
);

Vector2D wind = {config["wind"]["X"].value_or(0.0), config["wind"]["Y"].value_or(0.0)}; 
Vector2D flow = {config["flow"]["X"].value_or(0.0), config["flow"]["Y"].value_or(0.0)};

std::vector<IslandData> Islands(config["IslandCount"].value_or(10));
int islandCount = config["IslandCount"].value_or(10);
bool Logs = config["Logs"].value_or(false);
Collider boatCollider;

double Thrust = 0.0;
double Angle = 0.0;

double timeScale = 0.2;
int i = 1;
std::string finalTime;



std::string info(std::string_view sep = " | ") {
    return std::format(
        "Т={:.1f}с{}{}: ({:.1f}, {:.1f}){}{}: {:.1f}{}{}: {:.1f}{}{}: {:.1f} град.",
        i * 0.1,                          sep,
        "Позиция", boat.position.x, boat.position.y, sep,
        "Штурвал", Angle,                 sep,
        "Тяга", Thrust,                   sep,
        "Курс", boat.angle * 180.0 / 3.14159265358979
    );
}



void loadFlagTextures(SDL_Renderer* renderer) {
    for (int i = 0; i < 8; i++) {
        std::string path = "Assets/Textures/flag_" + std::to_string(i) + ".png";
        flagTextures[i] = IMG_LoadTexture(renderer, path.c_str());
        if (!flagTextures[i]) {
            std::cerr << "Ошибка загрузки: " << path << " | " << IMG_GetError() << std::endl;
        }
    }
}


int GetWindDirectionIndex(Vector2D w) {
    if (std::abs(w.x) < 0.001 && std::abs(w.y) < 0.001) return 0;

    double angle = atan2(w.y, w.x); 

    double degrees = angle * 180.0 / 3.1415926535;
    if (degrees < 0) degrees += 360.0;

    return (int)((degrees + 22.5) / 45.0) % 8;
}


void GenIslands(){
	srand(time(NULL));
	
    Islands.clear(); 

	for (int i = 0; i < islandCount; i++) {
        Collider c1, c2, c3; // c1-нижний, c2-средний, c3-верхний

        float fullW = ISLAND_WIDTH * ISLAND_MULT;
        float fullH = ISLAND_HEIGHT * ISLAND_MULT;
        
        c1.width = fullW * 0.7f;       
        c1.height = fullH * 0.3f; 
        c1.angle = 0.0f;

        c2.width = fullW * 1.0f; 
        c2.height = fullH * 0.3f;
        c2.angle = 0.0f;

        c3.width = fullW * 0.7f; 
        c3.height = fullH * 0.4f;
        c3.angle = 0.0f;
    
		bool placed = false;
    	for (int attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        	int nx = Engine_Random(MARGIN, 1920 - MARGIN - (int)fullW);
        	int ny = Engine_Random(MARGIN, 1080 - MARGIN - (int)fullH);
        
        	c3.x = nx + (fullW - c3.width) / 2.0f;
        	c3.y = ny + 20; 
            
            c2.x = nx + (fullW - c2.width) / 2.0f; 
            c2.y = ny + 20 + c3.height * 0.5f;

            c1.x = nx + (fullW - c1.width) / 2.0f; 
            c1.y = c2.y + c2.height * 0.8f;


        	bool hasCollision = false;
			if(c1.checkCollision(boatCollider) or c2.checkCollision(boatCollider) or c3.checkCollision(boatCollider)){
				hasCollision = true;
			}else{
        		for (int k = 0; k < Islands.size(); k++) {
                    for(const auto& existingCollider : Islands[k].colliders) {
            		    if (c2.checkCollision(existingCollider)) { 
                		    hasCollision = true;
                		    break;
					    }
                    }
                    if (hasCollision) break;
        		}
			}

        	if (!hasCollision) {
            	placed = true;
                IslandData currentIsland;
                currentIsland.drawX = nx;
                currentIsland.drawY = ny;
                currentIsland.drawWidth = fullW;
                currentIsland.drawHeight = fullH;

                currentIsland.colliders.push_back(c1);
                currentIsland.colliders.push_back(c2);
                currentIsland.colliders.push_back(c3);
                Islands.push_back(currentIsland); 
            	break;        	
            }
    	}

    	if (!placed) {
        	std::cerr << "Не удалось разместить остров #" << i << " (недостаточно места)" << std::endl;
    	}
	}
}


void Draw(SDL_Window *window, SDL_Renderer *renderer) { 
    for(int k = 0; k < Islands.size(); k++) {
        SDL_Rect dstRect = { 
            (int)Islands[k].drawX, 
            (int)Islands[k].drawY, 
            (int)Islands[k].drawWidth, 
            (int)Islands[k].drawHeight
        };
        SDL_RenderCopy(renderer, island, NULL, &dstRect);
    }

    rect = {int(boat.position.x * 100), int(boat.position.y * 100), 180, 99};
    const double RAD_TO_DEG = 180.0 / 3.141592653589793;
    
    SDL_RenderCopyEx(renderer, ship, NULL, &rect, boat.angle * RAD_TO_DEG, &center, SDL_FLIP_NONE);
    Light1.draw(renderer);
    Light2.draw(renderer);
}



void TableMenu(SDL_Window *window, SDL_Renderer *renderer, const char* Text) {
    Uint8 oldR, oldG, oldB, oldA;
    SDL_GetRenderDrawColor(renderer, &oldR, &oldG, &oldB, &oldA);

    int WindowWidth, WindowHeight;
    SDL_GetWindowSize(window, &WindowWidth, &WindowHeight);

    float textWidth = FC_GetWidth(DepartureMonoNerdFontTitle, Text);
    float textHeight = FC_GetHeight(DepartureMonoNerdFontTitle, Text); 

    int padding = 40;
    SDL_Rect rect;
    rect.w = (int)textWidth + padding * 2;
    rect.h = (int)textHeight + padding * 2;
    
    if (rect.w < WindowWidth / 3) rect.w = WindowWidth / 3;

    rect.x = (WindowWidth - rect.w) / 2;
    rect.y = (WindowHeight - rect.h) / 2;

    SDL_SetRenderDrawColor(renderer, 102, 57, 49, 255);
    SDL_RenderFillRect(renderer, &rect);

    SDL_Rect innerRect = rect;
    innerRect.x += 10;
    innerRect.y += 10;
    innerRect.w -= 20;
    innerRect.h -= 20;

    SDL_SetRenderDrawColor(renderer, 143, 86, 59, 255); 
    SDL_RenderFillRect(renderer, &innerRect);

    FC_DrawAlign(DepartureMonoNerdFontTitle, 
                 renderer, 
                 WindowWidth / 2,
                 rect.y + padding,
                 FC_ALIGN_CENTER,
                 Text);

    SDL_SetRenderDrawColor(renderer, oldR, oldG, oldB, oldA);
}


void cornerMenu(SDL_Window *window, SDL_Renderer *renderer, const char* Text) {
    Uint8 oldR, oldG, oldB, oldA;

    SDL_GetRenderDrawColor(renderer, &oldR, &oldG, &oldB, &oldA);

	float textHeight = FC_GetHeight(DepartureMonoNerdFont, Text); 

    SDL_Rect rect;
	rect.w = WindowWidth / 5;
    rect.x = WindowWidth - rect.w;
    rect.y = 0;
    rect.h = textHeight + 40;

	SDL_SetRenderDrawColor(renderer, 102, 57, 49, 255);
	SDL_RenderFillRect(renderer, &rect);

	rect.x += 20;
    rect.y += 20;
    rect.w -= 40;
    rect.h -= 40;

    SDL_SetRenderDrawColor(renderer, 143, 86, 59, 255); 
    SDL_RenderFillRect(renderer, &rect);

    SDL_Rect centeredRect = { rect.x, 20, rect.w, (int)textHeight };
    
    FC_DrawBoxAlign(DepartureMonoNerdFont, renderer, centeredRect, FC_ALIGN_CENTER, Text);

    SDL_SetRenderDrawColor(renderer, oldR, oldG, oldB, oldA);
}


void FlagsMenu(SDL_Window *window, SDL_Renderer *renderer) {
    Uint8 oldR, oldG, oldB, oldA;
    SDL_GetRenderDrawColor(renderer, &oldR, &oldG, &oldB, &oldA);

    int mainBgColorR = 102, mainBgColorG = 57, mainBgColorB = 49;
    int innerBgColorR = 143, innerBgColorG = 86, innerBgColorB = 59;
    int padding = 20;

    SDL_Rect mainRect;
    mainRect.w = WindowWidth / 5;
    mainRect.h = WindowHeight / 9; 
    mainRect.x = WindowWidth - mainRect.w;
    mainRect.y = WindowHeight - mainRect.h;

    SDL_SetRenderDrawColor(renderer, mainBgColorR, mainBgColorG, mainBgColorB, 255);
    SDL_RenderFillRect(renderer, &mainRect);

    SDL_Rect innerRect;
    innerRect.x = mainRect.x + padding;
    innerRect.y = mainRect.y + padding;
    innerRect.w = mainRect.w - padding * 2;
    innerRect.h = mainRect.h - padding * 2;

    SDL_SetRenderDrawColor(renderer, innerBgColorR, innerBgColorG, innerBgColorB, 255); 
    SDL_RenderFillRect(renderer, &innerRect);
    

    int columnW = innerRect.w / 2;
    int iconSize = innerRect.h * 0.6; 
    
    int leftCenterX = innerRect.x + columnW / 2;
    int rightCenterX = innerRect.x + columnW + columnW / 2;
    int iconY = innerRect.y + 10; 

    SDL_Rect flagRect = { leftCenterX - iconSize / 2, iconY, iconSize, iconSize };
    SDL_Rect flowRect = { rightCenterX - iconSize / 2, iconY, iconSize, iconSize };

    if (wind.x != 0 || wind.y != 0) {
        SDL_RenderCopy(renderer, flagTextures[GetWindDirectionIndex(wind)], NULL, &flagRect);
        
        float windSpeed = sqrt(wind.x * wind.x + wind.y * wind.y);
        std::string windStr = std::format("{:.1f}", windSpeed);
        
        FC_DrawAlign(DepartureMonoNerdFont, renderer, leftCenterX, flagRect.y + flagRect.h + 5, FC_ALIGN_CENTER, windStr.c_str());
    }

    if (flow.x != 0 || flow.y != 0) {
        double angleDeg = (atan2(flow.y, flow.x) * 180.0 / M_PI) + 90;
        SDL_Point flowCenter = { flowRect.w / 2, flowRect.h / 2 };
        SDL_RenderCopyEx(renderer, flowArrowTexture, NULL, &flowRect, angleDeg, &flowCenter, SDL_FLIP_NONE);

        float flowSpeed = sqrt(flow.x * flow.x + flow.y * flow.y);
        std::string flowStr = std::format("{:.1f}", flowSpeed);

        FC_DrawAlign(DepartureMonoNerdFont, renderer, rightCenterX, flowRect.y + flowRect.h + 5, FC_ALIGN_CENTER, flowStr.c_str());
    }

    SDL_SetRenderDrawColor(renderer, oldR, oldG, oldB, oldA);
}




int start(SDL_Window *window, SDL_Renderer *renderer){	
	SDL_GetWindowSize(window, &WindowWidth, &WindowHeight);

	FC_LoadFont(DepartureMonoNerdFont, renderer, "Assets/Fonts/DepartureMono/DepartureMonoNerdFont-Regular.ttf", 20, FC_MakeColor(255,255,255,255), TTF_STYLE_NORMAL);
	FC_LoadFont(DepartureMonoNerdFontTitle, renderer, "Assets/Fonts/DepartureMono/DepartureMonoNerdFont-Regular.ttf", 48, FC_MakeColor(255,255,255,255), TTF_STYLE_NORMAL);

	ship = IMG_LoadTexture(renderer, "Assets/Textures/ship.png");	

    Light1.loadTexture(renderer, "Assets/Textures/light.png");
    Light1.collider.width *= 2;
    Light1.collider.height *= 2;
    Light1.collider.x = WindowWidth - 150;
    Light1.collider.y = WindowHeight - (WindowHeight / 5) - 300;

    Light2.loadTexture(renderer, "Assets/Textures/light.png");
    Light2.collider.width *= 2;
    Light2.collider.height *= 2;
    Light2.collider.x = WindowWidth - 150;
    Light2.collider.y = WindowHeight - 300;

    finish.width = 5;
    finish.height = WindowHeight / 5;
    finish.x = WindowWidth - 140;
    finish.y = WindowHeight - (WindowHeight / 5) - 300 + 70;

	island = IMG_LoadTexture(renderer, "Assets/Textures/Island.png");
	flowArrowTexture = IMG_LoadTexture(renderer, "Assets/Textures/Arrow.png");
	loadFlagTextures(renderer);

	flowRect = { WindowWidth - 174, WindowHeight - 74, 64, 64};
	if (!ship or !island or !flowArrowTexture) {
    	std::cerr << "Ошибка загрузки текстур: " << IMG_GetError() << std::endl;
	}
	SDL_SetRenderDrawColor(renderer, 99, 155, 255, 255);
	boatCollider.width = 180;
	boatCollider.height = 99;

	GenIslands();
	return 0;
}


int loop(SDL_Window *window, SDL_Renderer *renderer){
	boatCollider.x = boat.position.x * 100;
	boatCollider.y = boat.position.y * 100;
	boatCollider.angle = boat.angle * RAD_TO_DEG;;

	Draw(window, renderer);

	for (int j = 0; j < Islands.size(); j++){ 
        for(const auto& islandCollider : Islands[j].colliders) {
			if(Logs) islandCollider.draw(renderer);
		    if(boatCollider.checkCollision(islandCollider)){
			    std::cout << "END.";
			    game_is_running = false;
		    }
        }
	}

	Thrust = fmin(fmax(Thrust - Engine_GetAxis::Y() * 0.1, -5.0),5);
    Angle = std::clamp(Angle - (Engine_GetAxis::X() * ((Thrust > 0) ? 1.0 : ((Thrust < 0) ? -1.0 : 0.0))), -70.0, 70.0);

    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        if (event.type == SDL_QUIT || 
           (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_ESCAPE)) {
            return 1;
        }
        if (event.type == SDL_MOUSEWHEEL) {
            float sensitivity = 5.0f;
            Angle = std::clamp(Angle + event.wheel.y * sensitivity, -70.0, 70.0);
        }
        if (event.type == SDL_KEYDOWN) {
            if (event.key.keysym.sym == SDLK_p) {
                game_is_running = !game_is_running;
			    pause = !pause;
            }
        }
    }

	std::cout << i;
    if(Logs) {
		std::cout << info("|") << std::endl;
		boatCollider.draw(renderer);
        finish.draw(renderer);
	}

    if (boatCollider.checkCollision(finish)) {    
        if (f == false) {
            finalTime = std::to_string(i * 0.1);
        }

        std::string message = "Игра окончена. Ваше время: " + finalTime;
        TableMenu(window, renderer, message.c_str());

        game_is_running = false;
        f = true;
    }
	if(game_is_running) {
		cornerMenu(window, renderer, info("\n").c_str());
		boat.update(0.1 * timeScale, Thrust, Angle, wind, flow);
	} else {
		if (!pause and !f) {
			TableMenu(window, renderer, "Игра окончена.");
		} else if (!f) {
			TableMenu(window, renderer, "Пауза");
		}
	}

    FlagsMenu(window, renderer);
		
	i++;
	return 0;
}